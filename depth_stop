import rclpy, numpy as np, time
from rclpy.node import Node
from sensor_msgs.msg import Image
from std_msgs.msg import Bool, Float32
from cv_bridge import CvBridge

class DepthStop(Node):
    def __init__(self):
        super().__init__('depth_stop')
        self.declare_parameter('depth_topic', '/camera/aligned_depth_to_color/image_raw')
        self.declare_parameter('roi_ratio', 0.3)       
        self.declare_parameter('stop_distance', 0.45) 
        self.declare_parameter('hold_time', 0.5)    

        self.bridge = CvBridge()
        self.roi_ratio = float(self.get_parameter('roi_ratio').value)
        self.stop_dist = float(self.get_parameter('stop_distance').value)
        self.hold_time = float(self.get_parameter('hold_time').value)

        self.pub_stop = self.create_publisher(Bool, 'depth_stop', 10)
        self.pub_min  = self.create_publisher(Float32, 'min_front_dist', 10)

        self._last_block = 0.0
        self.create_subscription(Image,
            self.get_parameter('depth_topic').value, self.on_depth, 10)
        self.create_timer(0.05, self.tick)

    def on_depth(self, msg: Image):
        depth = self.bridge.imgmsg_to_cv2(msg, desired_encoding='passthrough')  # uint16 mm
        dm = depth.astype(np.float32) / 1000.0
        h,w = dm.shape
        rw, rh = int(w*self.roi_ratio), int(h*self.roi_ratio)
        x0, y0 = (w-rw)//2, (h-rh)//2
        roi = dm[y0:y0+rh, x0:x0+rw]
        roi = roi[np.isfinite(roi) & (roi>0)]
        if roi.size==0:
            return
        d = float(np.percentile(roi, 20))  
        self.pub_min.publish(Float32(data=d))
        if d < self.stop_dist:
            self._last_block = time.time()

    def tick(self):
        active = (time.time() - self._last_block) < self.hold_time
        self.pub_stop.publish(Bool(data=active))

def main():
    rclpy.init(); rclpy.spin(DepthStop()); rclpy.shutdown()
if __name__=='__main__':
    main()
